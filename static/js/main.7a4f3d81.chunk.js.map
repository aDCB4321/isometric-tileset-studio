{"version":3,"sources":["Isometry.js","App.js","serviceWorker.js","index.js"],"names":["ColorRgba","color","r","g","b","a","undefined","this","c","Color","Math","floor","red","green","blue","valpha","value","rgb","alpha","darken","lighten","saturate","desaturate","toRgbaString","hex","colorA","colorB","TransparentColor","create","Vector2","x","y","Area","width","height","Stroke","size","inner","Border","top","right","bottom","left","PolyhedronColorPalette","base","dark","darker","light","lighter","border","baseColor","Painter","canvas","getContext","scale","getImageData","getColorIndex","redIndex","greenIndex","blueIndex","alphaIndex","data","err","console","error","getWidth","getHeight","clearRect","offset","strokeWidth","isOutOfBounds","setColorToCanvasPixel","tx","ty","edge","x0","from","y0","x1","to","y1","dx","abs","sx","dy","sy","putPixel","strokeColor","e2","targetColor","equals","pixelColor","getColorAt","queue","push","length","node","shift","forEach","vec2","surface","i","edges","putEdge","poly","surfaces","putSurface","center","putFloodFillQ","fillColor","putImageData","vertices","verticesCount","j","borders","Error","ID_OUT_OF_POLYGON","ID_OUTER_BORDER","ID_INNER_BORDER","ID_FILL","flatVertices","map","v","xs","xy","ys","minX","min","maxX","max","minY","maxY","pixelMask","isPositionInPolygon","neighbourPixels","bx","by","stroke","isDrawable","opts","tileWidth","tileHeight","sizeX","sizeY","sizeZ","tilew","tileh","size_x","size_y","size_z","perspective","rotation","rx","ry","posX","posY","half_tilew","half_tileh","size_yx","size_yz","noStroke","asInner","lightStroke","middleLeftStroke","middleRightStroke","topColor","leftColor","rightColor","lightStrokeColor","colorPalette","generate","middleLeftStrokeSize","ceil","middleRightStrokeSize","blackStroke","topVertices","leftVertices","rightVertices","drawPolygon","defaults","CANVAS_WIDTH","CANVAS_HEIGHT","Layer","props","index","options","canvasRef","React","createRef","onDraw","painter","current","draw","className","style","zIndex","ref","drawIsometricCube","update","Component","App","updateCoolDownTimeout","updateTimeoutDelay","keyCount","updateForm","bind","handleInputNumChange","handleBaseColorChange","handleStrokeColorChange","handleStrokeSizeChange","handleZoomChange","handleGridChange","addLayer","onLayerChange","handleGridSnapChange","downloadLayers","copyLayers","handlePosXChange","handlePosYChange","viewportContainer","layersContainer","canvasGrid","state","zoom","layers","snapToGrid","currentLayer","getCurrentOptions","drawGrid","target","registerScrollOnDrag","snapMoveStepX","snapMoveStepXHalf","snapMoveStepY","moveStepX","moveStepXHalf","moveStepY","round","name","type","step","onChange","checked","makeLayerComboItems","onClick","id","createLayer","makeLayers","data-movestepy","data-movestepx","toHexString","event","triggerStateChange","parseInt","layerIndex","layerOpts","layer","currOpts","Object","assign","triggerPropsStateChange","startX","startY","scrollLeft","scrollTop","el","isDown","addEventListener","e","classList","add","pageX","offsetLeft","pageY","offsetTop","remove","preventDefault","walkX","walkY","callback","setState","prevState","propName","propValue","val","valY","dataset","movestepy","triggerOptionsStateChangeMultiple","valX","movestepx","triggerOptionsStateChange","parseFloat","combined","document","createElement","ctx","getElementsByClassName","Array","prototype","call","drawImage","navigator","clipboard","write","combineLayers","toBlob","blob","ClipboardItem","dataURL","toDataURL","link","download","href","click","lineColor","translate","block","z","save","beginPath","moveTo","lineTo","closePath","fillStyle","fill","restore","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.7a4f3d81.chunk.js","sourcesContent":["// GEOMETRY\nimport Color from 'color/index'\n\nclass ColorRgba {\n    r;\n    g;\n    b;\n    a;\n\n    constructor(color) {\n        if (!color) {\n            color = {r: 0, g: 0, b: 0, a: 255}\n        }\n        if (color instanceof ColorRgba || (color.r !== undefined && color.a !== undefined)) {\n            this.r = color.r\n            this.g = color.g\n            this.b = color.b\n            this.a = color.a\n        } else {\n            let c = Color(color)\n            this.r = Math.floor(c.red())\n            this.g = Math.floor(c.green())\n            this.b = Math.floor(c.blue())\n            this.a = Math.floor(c.valpha * 255)\n        }\n    }\n\n    static create(r, g, b, a) {\n        return new this({r: r, g: g, b: b, a: a})\n    }\n\n    static equals(colorA, colorB) {\n        return colorA.r === colorB.r && colorA.g === colorB.g\n            && colorA.b === colorB.b && colorA.a === colorB.a;\n    }\n\n\n    darken(value) {\n        return new ColorRgba(Color.rgb(this.r, this.g, this.b).alpha(this.a / 255).darken(value))\n    }\n\n    lighten(value) {\n        return new ColorRgba(Color.rgb(this.r, this.g, this.b).alpha(this.a / 255).lighten(value))\n    }\n\n    saturate(value) {\n        return new ColorRgba(Color.rgb(this.r, this.g, this.b).alpha(this.a / 255).saturate(value))\n    }\n\n    desaturate(value) {\n        return new ColorRgba(Color.rgb(this.r, this.g, this.b).alpha(this.a / 255).desaturate(value))\n    }\n\n    toString() {\n        return this.toRgbaString()\n    }\n\n    toRgbaString() {\n        return `rgba(${this.r},${this.g},${this.b},${this.a})`\n    }\n\n    toHexString() {\n        return (new Color({r: this.r, g: this.g, b: this.b}).alpha(this.a / 255)).hex()\n    }\n}\n\nconst TransparentColor = ColorRgba.create(0, 0, 0, 0)\n\nclass Vector2 {\n    x;\n    y;\n\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n\n    toString() {\n        return `(${this.x},${this.y})`\n    }\n}\n\n\nclass Vector3 extends Vector2 {\n    z;\n\n    constructor(x = 0, y = 0, z = 0) {\n        super(x, y);\n        this.z = z;\n    }\n\n    toString() {\n        return `(${this.x},${this.y},${this.z})`\n    }\n}\n\nclass Rect extends Vector2 {\n    width;\n    height;\n\n    constructor(x = 0, y = 0, width = 0, height = 0) {\n        super(x, y);\n        this.width = width;\n        this.height = height;\n    }\n\n    toString() {\n        return `(${this.x},${this.y},${this.width}x${this.height})`\n    }\n}\n\nclass Area {\n    width;\n    height;\n\n    constructor(width = 0, height = 0) {\n        this.width = width;\n        this.height = height;\n    }\n\n    toString() {\n        return `(${this.width}x${this.height})`\n    }\n}\n\nclass Pixel {\n    x;\n    y;\n    color;\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @param {ColorRgba} color\n     */\n    constructor(x, y, color) {\n        this.x = x;\n        this.y = y;\n        this.color = color;\n    }\n}\n\nclass Stroke {\n    size;\n    color;\n    inner = false;\n\n    /**\n     *\n     * @param {number} size\n     * @param {ColorRgba} color\n     * @param {boolean} inner\n     */\n    constructor(size = 0, color = null, inner = false) {\n        this.size = Math.floor(size ? size : 0)\n        this.color = color ? color : TransparentColor\n        this.inner = inner\n    }\n\n    asInner() {\n        this.inner = true\n        return this\n    }\n\n    asOuter() {\n        this.inner = false\n        return this\n    }\n\n    isDrawable() {\n        return this.size > 0 || this.color.a > 0\n    }\n}\n\nclass Border {\n    top;\n    right;\n    bottom;\n    left;\n\n    /**\n     * @param {Stroke|null} top\n     * @param {Stroke|null} right\n     * @param {Stroke|null} bottom\n     * @param {Stroke|null} left\n     */\n    constructor(top, right, bottom, left) {\n        this.top = top ? top : new Stroke(0);\n        this.right = right ? right : new Stroke(0);\n        this.bottom = bottom ? bottom : new Stroke(0);\n        this.left = left ? left : new Stroke(0);\n    }\n}\n\nclass Edge {\n    from;\n    to;\n    strokeColor;\n    strokeWidth;\n\n    /**\n     * @param {Vector2} from\n     * @param {Vector2} to\n     * @param {string} strokeColor\n     * @param {number} strokeWidth\n     */\n    constructor(from, to, strokeColor, strokeWidth) {\n        this.from = from;\n        this.to = to;\n        this.strokeColor = strokeColor;\n        this.strokeWidth = strokeWidth;\n    }\n\n    static create(x0, y0, x1, y1, strokeColor) {\n        return new this(new Vector2(x0, y0), new Vector2(x1, y1), strokeColor, 1)\n    }\n\n    toString() {\n        return `(${this.from} -> ${this.to}, ${this.strokeColor}, ${this.strokeWidth})`\n    }\n}\n\nclass Surface {\n    edges;\n    fillColor;\n    center;\n\n    /**\n     * @param {string} fillColor\n     * @param {Edge[]} edges\n     */\n    constructor(fillColor, ...edges) {\n        this.edges = edges;\n        this.fillColor = fillColor;\n        this.center = new Vector2(0, 0)\n    }\n\n    toString() {\n        let s = `(${this.center}, ${this.fillColor}):\\n`\n        for (let i in this.edges) {\n            s += \"##\" + (i + 1) + this.edges[i] + \"\\n\"\n        }\n        return s\n    }\n}\n\nclass Polyhedron {\n    surfaces;\n\n    /**\n     * @param {Surface[]} surfaces\n     */\n    constructor(...surfaces) {\n        this.surfaces = surfaces;\n    }\n\n    toString() {\n        let s = `------`\n        for (let i in this.surfaces) {\n            s += \"#\" + (i + 1) + this.surfaces[i] + \"\\n---\\n\"\n        }\n        return s + `------`\n    }\n}\n\nclass PolyhedronColorPalette {\n    base;\n    dark;\n    darker;\n    light;\n    lighter;\n    border;\n\n    /**\n     * @param {ColorRgba} base\n     * @param {ColorRgba} dark\n     * @param {ColorRgba} darker\n     * @param {ColorRgba} light\n     * @param {ColorRgba} lighter\n     * @param {ColorRgba} border\n     */\n    constructor(base, dark, darker, light, lighter, border) {\n        this.base = new ColorRgba(base);\n        this.dark = new ColorRgba(dark);\n        this.darker = new ColorRgba(darker);\n        this.light = new ColorRgba(light);\n        this.lighter = new ColorRgba(lighter);\n        this.border = new ColorRgba(border);\n    }\n\n    /**\n     * @param {ColorRgba|string} baseColor\n     * @return {PolyhedronColorPalette}\n     */\n    static generate(baseColor) {\n        let base = new ColorRgba(baseColor)\n        return new this(\n            base,\n            base.saturate(0.2).darken(0.2),\n            base.saturate(0.2).darken(0.4),\n            base.saturate(0.1).lighten(0.2),\n            base.saturate(0.4).lighten(0.4),\n            new ColorRgba('#000000')\n        )\n    }\n}\n\nclass PolyhedronFactoryOptions {\n    position;\n    size;\n    angle;\n    strokeWidth;\n    colors;\n\n    /**\n     * @param {Vector2} position\n     * @param {Vector3} size\n     * @param {number} angle\n     * @param {number} strokeWidth\n     * @param {PolyhedronColorPalette} colors\n     */\n    constructor(position, size, angle, strokeWidth, colors) {\n        this.position = position;\n        this.size = size;\n        this.angle = angle;\n        this.strokeWidth = strokeWidth;\n        this.colors = colors;\n    }\n\n    /**\n     * @param {number} posX\n     * @param {number} posY\n     * @param {number} sizeX\n     * @param {number} sizeZ\n     * @param {number} sizeY\n     * @param {number} angle\n     * @param {number} strokeWidth\n     * @param {ColorRgba|string} baseColor\n     * @returns {PolyhedronFactoryOptions}\n     */\n    static createQuickOptions(posX, posY, sizeX, sizeZ, sizeY, angle, strokeWidth, baseColor) {\n        return new this(\n            new Vector2(posX, posY),\n            new Vector3(sizeX, sizeY, sizeZ),\n            angle,\n            strokeWidth,\n            PolyhedronColorPalette.generate(baseColor)\n        )\n    }\n}\n\nclass PolyhedronFactory {\n    /**\n     * @param {PolyhedronFactoryOptions} options\n     * @return Polyhedron\n     */\n    static createCube(options) {\n        let rotation = (options.angle + 100 - options.strokeWidth) / (100 - options.strokeWidth)\n        let size_x = options.size.x\n        let size_z = options.size.z\n        let size_y = options.size.y\n        let size_yx = Math.floor(size_x / rotation)\n        let size_yz = Math.floor(size_z / rotation)\n        let pos = options.position\n        let min_w = options.strokeWidth * 2\n        let min_h = options.strokeWidth * 2\n\n// CALC VERTICES\n        let v = {}\n        v.topLeft = new Vector2(pos.x, pos.y + min_h)\n        v.topUp = new Vector2(pos.x + min_w, pos.y)\n        v.topRight = new Vector2(pos.x + (min_w * 2), v.topLeft.y)\n        v.topDown = new Vector2(v.topUp.x, pos.y + (min_h * 2))\n        v.bottomLeft = new Vector2(v.topLeft.x, v.topLeft.y)\n        v.bottomDown = new Vector2(v.topUp.x, v.topDown.y)\n        v.bottomRight = new Vector2(v.topRight.x, v.topRight.y)\n\n// apply lengths\n        v.topUp.x = v.topUp.x + ((-1 * size_x) + size_z)\n        v.topUp.y = v.topUp.y - (size_yx + size_yz)\n\n// left\n        v.topLeft.x = v.topLeft.x - size_x\n        v.topLeft.y = v.topLeft.y - size_yx\n        v.bottomLeft.x = v.bottomLeft.x - size_x\n        v.bottomLeft.y = v.bottomLeft.y - size_yx\n\n// right\n        v.topRight.x = v.topRight.x + size_z\n        v.topRight.y = v.topRight.y - size_yz\n        v.bottomRight.x = v.bottomRight.x + size_z\n        v.bottomRight.y = v.bottomRight.y - size_yz\n\n// apply height (+Y)\n        v.bottomLeft.y = v.bottomLeft.y + size_y\n        v.bottomDown.y = v.bottomDown.y + size_y\n        v.bottomRight.y = v.bottomRight.y + size_y\n\n// CALC EDGES and POLYGONS with their center points\n        let ed = {}\n        let bw = options.strokeWidth\n\n// top polygon\n        ed.topLeftTopUp = new Edge(v.topLeft, v.topUp, options.colors.border, bw)\n        ed.topUpTopRight = new Edge(v.topUp, v.topRight, options.colors.border, bw)\n        ed.topRightTopDown = new Edge(v.topRight, v.topDown, options.colors.light, bw)\n        ed.topDownTopLeft = new Edge(v.topDown, v.topLeft, options.colors.light, bw)\n        let topPoly = new Surface(\n            options.colors.base,\n            ed.topLeftTopUp,\n            ed.topUpTopRight,\n            ed.topRightTopDown,\n            ed.topDownTopLeft\n        )\n        topPoly.center.x = Math.floor((v.topLeft.x + v.topRight.x) / 2)\n        topPoly.center.y = Math.floor((v.topUp.y + v.topDown.y) / 2)\n\n// left polygon\n        ed.topLeftBottomLeft = new Edge(v.topLeft, v.bottomLeft, options.colors.border, bw)\n        ed.topDownBottomDown = new Edge(v.topDown, v.bottomDown, options.colors.light, bw)\n        ed.bottomLeftBottomDown = new Edge(v.bottomLeft, v.bottomDown, options.colors.border, bw)\n        let leftPoly = new Surface(\n            options.colors.dark,\n            ed.topDownTopLeft,\n            ed.topLeftBottomLeft,\n            ed.topDownBottomDown,\n            ed.bottomLeftBottomDown\n        )\n        leftPoly.center.x = Math.floor((v.topLeft.x + v.topDown.x) / 2)\n        leftPoly.center.y = Math.floor(((v.topLeft.y + v.bottomLeft.y) / 2) + (size_y / 2))\n\n        ed.bottomRightBottomDown = new Edge(v.bottomRight, v.bottomDown, options.colors.border, bw)\n        ed.topRightBottomRight = new Edge(v.topRight, v.bottomRight, options.colors.border, bw)\n        let rightPoly = new Surface(\n            options.colors.darker,\n            ed.topRightTopDown,\n            ed.topDownBottomDown,\n            ed.topRightBottomRight,\n            ed.bottomRightBottomDown\n        )\n        rightPoly.center.x = Math.floor((v.topRight.x + v.topDown.x) / 2)\n        rightPoly.center.y = Math.floor(((v.topRight.y + v.bottomRight.y) / 2) + (size_y / 2))\n\n        return new Polyhedron(topPoly, leftPoly, rightPoly)\n    }\n}\n\nclass PolyhedronOptions {\n    posX;\n    posY;\n    tileWidth;\n    tileHeight;\n    sizeX;\n    sizeY;\n    sizeZ;\n    rotation;\n    stroke;\n    baseColor;\n\n    /**\n     * @param {number} posX\n     * @param {number} posY\n     * @param {number} tileWidth\n     * @param {number} tileHeight\n     * @param {number} sizeX\n     * @param {number} sizeY\n     * @param {number} sizeZ\n     * @param {number} rotation\n     * @param {Stroke} stroke\n     * @param {ColorRgba} baseColor\n     */\n    constructor(posX, posY, tileWidth, tileHeight, sizeX, sizeY, sizeZ, rotation, stroke, baseColor) {\n        this.posX = posX;\n        this.posY = posY;\n        this.tileWidth = tileWidth;\n        this.tileHeight = tileHeight;\n        this.sizeX = sizeX;\n        this.sizeY = sizeY;\n        this.sizeZ = sizeZ;\n        this.rotation = rotation;\n        this.stroke = stroke;\n        this.baseColor = baseColor;\n    }\n}\n\nclass Painter {\n    /**\n     * @property {HTMLCanvasElement} canvas\n     */\n    #canvas;\n\n    /**\n     * @property {ImageBitmapRenderingContext | CanvasRenderingContext2D }\n     */\n    #ctx;\n\n    /**\n     * @property {CanvasImageData | ImageData }\n     */\n    #imageData;\n\n    /**\n     * @param {HTMLCanvasElement} canvas\n     */\n    constructor(canvas) {\n        this.#canvas = canvas\n        this.#ctx = this.#canvas.getContext('2d')\n        this.#ctx.scale(5, 5)\n        this.#imageData = this.#ctx.getImageData(\n            0, 0, this.#canvas.width, this.#canvas.height\n        )\n    }\n\n    getColorIndex(x, y) {\n        //  // 4*y*canvas.width  +  4*x + 3\n        return ((y * this.#imageData.width * 4) + (x * 4))\n    }\n\n    /**\n     * @param {number} x\n     * @param {number} y\n     * @return {ColorRgba}\n     */\n    getColorAt(x, y) {\n        const red = this.getColorIndex(x, y);\n        const [redIndex, greenIndex, blueIndex, alphaIndex] = [red, red + 1, red + 2, red + 3];\n        const c = {\n            r: this.#imageData.data[redIndex],\n            g: this.#imageData.data[greenIndex],\n            b: this.#imageData.data[blueIndex],\n            a: this.#imageData.data[alphaIndex]\n        }\n\n        if (c.r === undefined || c.g === undefined || c.b === undefined || c.a === undefined) {\n            let err = \"Pixel does not exist at \" + new Vector2(x, y)\n            console.error(err, c)\n            return null\n        }\n        return new ColorRgba(c)\n    }\n\n    drawIsometricGrid() {\n\n    }\n\n    /**\n     * @param {number} x\n     * @param {number} y\n     * @return {boolean}\n     */\n    isOutOfBounds(x, y) {\n        return (x < 0) || (x > this.getWidth()) || (y < 0) || (y > this.getHeight())\n    }\n\n    /**\n     * @return {number}\n     */\n    getWidth() {\n        return this.#imageData.width\n    }\n\n    /**\n     * @return {number}\n     */\n    getHeight() {\n        return this.#imageData.height\n    }\n\n    /**\n     * @return {Area}\n     */\n    getSize() {\n        return new Area(this.#imageData.width, this.#imageData.height)\n    }\n\n    clearCanvas() {\n        this.#ctx.clearRect(0, 0, this.getWidth(), this.getHeight());\n        this.#imageData = this.#ctx.getImageData(0, 0, this.getWidth(), this.getHeight())\n    }\n\n    /**\n     * @param {number} x\n     * @param {number} y\n     * @param {ColorRgba} color\n     * @return {boolean}\n     */\n    setColorToCanvasPixel(x, y, color) {\n        let offset = this.getColorIndex(x, y);\n        this.#imageData.data[offset] = Math.floor(color.r);\n        this.#imageData.data[offset + 1] = Math.floor(color.g);\n        this.#imageData.data[offset + 2] = Math.floor(color.b);\n        this.#imageData.data[offset + 3] = Math.floor(color.a);\n    }\n\n    // @param {CanvasImageData} imageData\n    /**\n     * @param {number} x\n     * @param {number} y\n     * @param {ColorRgba} color\n     * @param {int} strokeWidth\n     * @return {boolean}\n     */\n    putPixel(x, y, color, strokeWidth) {\n        if (this.isOutOfBounds(x, y)) {\n            return false\n        }\n\n        if (strokeWidth === 1) {\n            this.setColorToCanvasPixel(x, y, color)\n            return true\n        }\n\n        for (let tx = 0; tx <= strokeWidth - 1; tx++) {\n            for (let ty = 0; ty <= strokeWidth - 1; ty++) {\n                this.setColorToCanvasPixel(x + tx, y + ty, color)\n            }\n        }\n    }\n\n    /**\n     * @see http://rosettacode.org/wiki/Bitmap/Bresenham's_line_algorithm#JavaScript\n     * @param {Edge} edge\n     */\n    putEdge(edge) {\n        let x0 = edge.from.x\n        let y0 = edge.from.y\n        let x1 = edge.to.x\n        let y1 = edge.to.y\n\n        let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;\n        let dy = Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;\n        let err = (dx > dy ? dx : -dy) / 2;\n        // TODO: support stroke width\n        while (true) {\n            this.putPixel(x0, y0, edge.strokeColor, 1)\n            if (x0 === x1 && y0 === y1) break;\n            let e2 = err;\n            if (e2 > -dx) {\n                err -= dy;\n                x0 += sx;\n            }\n            if (e2 < dy) {\n                err += dx;\n                y0 += sy;\n            }\n        }\n    }\n\n    /**\n     * Forest Fire Algorithm\n     * https://en.wikipedia.org/wiki/Flood_fill#The_algorithm\n     *\n     * @param {number} x\n     * @param {number} y\n     * @param {ColorRgba} color Replacement color\n     */\n    putFloodFillQ(x, y, color) {\n        let targetColor = TransparentColor\n        if (this.isOutOfBounds(x, y) || ColorRgba.equals(color, targetColor)) {\n            return\n        }\n        let pixelColor = this.getColorAt(x, y)\n        if (pixelColor !== null && ColorRgba.equals(pixelColor, targetColor) === false) {\n            return\n        }\n\n        this.setColorToCanvasPixel(x, y, color)\n\n        /**\n         * @type {Vector2[]}\n         */\n        let queue = []\n        queue.push(new Vector2(x, y))\n\n        while (queue.length > 0) {\n            let node = queue.shift();\n            [\n                new Vector2(node.x - 1, node.y),\n                new Vector2(node.x + 1, node.y),\n                new Vector2(node.x, node.y + 1),\n                new Vector2(node.x, node.y - 1)\n            ].forEach((vec2) => {\n                pixelColor = this.getColorAt(vec2.x, vec2.y)\n                if (pixelColor !== null && ColorRgba.equals(pixelColor, targetColor)) {\n                    this.setColorToCanvasPixel(vec2.x, vec2.y, color)\n                    queue.push(new Vector2(vec2.x, vec2.y))\n                }\n            });\n        }\n    }\n\n    /**\n     * @param {Surface} surface\n     */\n    putSurface(surface) {\n        for (let i in surface.edges) {\n            this.putEdge(surface.edges[i])\n        }\n    }\n\n    /**\n     * @param {Polyhedron} poly\n     */\n    putPolyhedron(poly) {\n        for (let i in poly.surfaces) {\n            this.putSurface(poly.surfaces[i])\n        }\n        for (let i in poly.surfaces) {\n            let center = poly.surfaces[i].center\n            this.putFloodFillQ(center.x, center.y, poly.surfaces[i].fillColor)\n        }\n    }\n\n    update() {\n        this.#ctx.putImageData(this.#imageData, 0, 0);\n    }\n\n    // https://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n    isPositionInPolygon(x, y, vertices) {\n        /* Determine if the point is in the path.\n\n        Args:\n          x -- The x coordinates of point.\n          y -- The y coordinates of point.\n          poly -- a list of tuples [(x, y), (x, y), ...]\n\n        Returns:\n          True if the point is in the path.\n        */\n\n        let verticesCount = vertices.length\n        let j = verticesCount - 1\n        let c = false\n        for (let i = 0; i < verticesCount; i++) {\n            if (((vertices[i][1] > y) !== (vertices[j][1] > y))\n                && (x < vertices[i][0] + (vertices[j][0] - vertices[i][0]) *\n                    (y - vertices[i][1]) / (vertices[j][1] - vertices[i][1]))) {\n\n                c = !c\n            }\n            j = i\n        }\n        return c\n    }\n\n    /**\n     *\n     * @param {Vector2[]} vertices\n     * @param {Border|null} borders\n     * @param {ColorRgba|null} fillColor\n     * @return {[[number, number]]}\n     */\n    drawPolygon(vertices, borders, fillColor = null) {\n        if (borders === null && fillColor === null) {\n            throw Error('Stroke and fill color cannot be both null.')\n        }\n\n        let ID_OUT_OF_POLYGON = 0,\n            ID_OUTER_BORDER = 1,\n            ID_INNER_BORDER = 2,\n            ID_FILL = 3;\n\n        // first, let's find the rect that we will have to scan pixel by pixel\n        // by calculating the minimum and maximum positions of all vertices.\n\n        let flatVertices = vertices.map((v) => [\n            Math.floor(v.x),\n            Math.floor(v.y)\n        ])\n        let xs = flatVertices.map((xy) => xy[0])\n        let ys = flatVertices.map((xy) => xy[1])\n        let minX = Math.min(...xs),\n            maxX = Math.max(...xs),\n            minY = Math.min(...ys),\n            maxY = Math.max(...ys);\n        let pixelMask = []\n\n        for (let x = minX; x <= maxX; x++) {\n            for (let y = minY; y <= maxY; y++) {\n                if (pixelMask[x] === undefined) {\n                    pixelMask[x] = []\n                }\n                pixelMask[x][y] = ID_OUT_OF_POLYGON;\n                if (!this.isPositionInPolygon(x, y, flatVertices)) {\n                    //this.putPixel(x, y, strokeColor, 1) // this would be a negative mask\n                    continue;\n                }\n                pixelMask[x][y] = ID_FILL;\n                if (fillColor !== null) {\n                    this.putPixel(x, y, fillColor, 1)\n                }\n            }\n        }\n\n        if (borders === null) {\n            return pixelMask;\n        }\n\n        // borders\n        for (let x = minX; x <= maxX; x++) {\n            for (let y = minY; y <= maxY; y++) {\n                if (pixelMask[x][y] < ID_FILL) {\n                    continue;\n                }\n                // borders\n                let neighbourPixels = [\n                    //[x + stroke.size, y + stroke.size],\n                    //[x - stroke.size, y - stroke.size],\n                    //[x - stroke.size, y - stroke.size],\n                    [x - borders.left.size, y, borders.left], // left border\n                    [x, y - borders.top.size, borders.top], // top border\n                    [x + borders.right.size, y, borders.right], // right border\n                    [x, y + borders.bottom.size, borders.bottom], // bottom border\n                    //[x - borders.left.size, y + borders.bottom.size, borders.bottom],\n                    //[x + stroke.size, y - stroke.size]\n                ];\n                for (let i = 0; i < neighbourPixels.length; i++) {\n                    let [bx, by, stroke] = neighbourPixels[i]\n\n                    if (!stroke.isDrawable()) {\n                        //continue;\n                    }\n\n                    if (pixelMask[bx] === undefined) {\n                        pixelMask[bx] = []\n                    }\n\n                    if (pixelMask[bx][by] === undefined) {\n                        pixelMask[bx][by] = ID_OUT_OF_POLYGON\n                    }\n\n                    if (pixelMask[bx][by] < ID_FILL) {\n                        if (stroke.inner) {\n                            pixelMask[bx][by] = ID_INNER_BORDER\n                            this.putPixel(x, y, stroke.color, 1)\n                        } else {\n                            // TODO fix outer border corners\n                            pixelMask[bx][by] = ID_OUTER_BORDER\n                            this.putPixel(bx, by, stroke.color, 1)\n                        }\n                    }\n                }\n            }\n        }\n\n        return pixelMask\n    }\n\n    drawIsometricCube(opts) {\n        let [tilew, tileh, size_x, size_y, size_z] = [\n            opts.tileWidth, opts.tileHeight, opts.sizeX, opts.sizeY, opts.sizeZ\n        ]\n\n        let perspective = (tilew / tileh)\n        let [rx, ry] = [opts.rotation, opts.rotation / perspective];\n\n        // tilew += Math.max(rx,1)\n        // tileh -= Math.max(ry,1)\n\n        let [x, y, half_tilew, half_tileh] = [\n            opts.posX, opts.posY + tileh / 2, tilew / 2, tileh / 2\n        ];\n\n        size_x -= half_tilew\n        size_z -= half_tilew\n\n        let size_yx = size_x / perspective\n        let size_yz = size_z / perspective\n\n        //console.log(tilew, tileh, size_x, size_y, size_yx, size_z, size_yz, perspective)\n\n        let noStroke = (new Stroke(0)).asInner()\n        let lightStroke = noStroke\n        let middleLeftStroke = noStroke\n        let middleRightStroke = noStroke\n        if (!opts.stroke) {\n            opts.stroke = noStroke\n        }\n\n        let topColor = null, leftColor = null, rightColor = null, lightStrokeColor = null;\n        if (opts.baseColor) {\n            let colorPalette = PolyhedronColorPalette.generate(opts.baseColor)\n            topColor = colorPalette.base\n            leftColor = colorPalette.dark\n            rightColor = colorPalette.darker\n            lightStrokeColor = colorPalette.light\n        }\n        if (opts.stroke.isDrawable()) {\n            lightStroke = new Stroke(opts.stroke.size, lightStrokeColor, opts.stroke.inner)\n            let middleLeftStrokeSize = Math.ceil(opts.stroke.size / 2)\n            let middleRightStrokeSize = Math.floor(opts.stroke.size / 2)\n\n            if (middleLeftStrokeSize > 0) {\n                middleLeftStroke = new Stroke(middleLeftStrokeSize, lightStrokeColor, opts.stroke.inner)\n            }\n            if (middleRightStrokeSize > 0) {\n                middleRightStrokeSize += 1\n                middleRightStroke = new Stroke(middleRightStrokeSize, lightStrokeColor, opts.stroke.inner)\n            }\n        }\n\n        let blackStroke = opts.stroke\n\n        // TOP face\n        let topVertices = [\n            new Vector2(x + rx, y + ry), // left\n            new Vector2(x + half_tilew - rx, y - half_tileh + ry), // top\n            new Vector2(x + tilew - rx, y - ry), // right\n            new Vector2(x + half_tilew + rx, y + half_tileh - ry), // bottom\n        ]\n\n        // LEFT face\n        let leftVertices = [\n            new Vector2(x + rx, y + size_y + ry), // left,down\n            topVertices[0], // left,top\n            topVertices[3], // middle,top\n            new Vector2(x + half_tilew + rx, y + (half_tileh) + size_y - ry), // middle,down\n        ]\n\n        // RIGHT face\n        let rightVertices = [\n            new Vector2(x + tilew - rx, y + size_y - ry), // right,down\n            topVertices[2], // right.top\n            topVertices[3], // middle,top\n            leftVertices[3], // middle,down\n        ]\n\n        // apply size\n        // Z\n        topVertices[1].x += size_z\n        topVertices[1].y -= (size_yz)\n        topVertices[2].x += size_z\n        topVertices[2].y -= (size_yz)\n        rightVertices[0].x += size_z\n        rightVertices[0].y -= (size_yz)\n\n\n        topVertices[0].x -= size_x\n        topVertices[0].y -= (size_yx)\n        topVertices[1].x -= size_x\n        topVertices[1].y -= (size_yx)\n        leftVertices[0].x -= size_x\n        leftVertices[0].y -= (size_yx)\n\n        // // pyramid\n        // topVertices = [\n        //     topVertices[1],\n        //     topVertices[1],\n        //     topVertices[1],\n        //     topVertices[1],\n        // ]\n\n        // // pyramid, inverted\n        // leftVertices[0] = leftVertices[3]\n        // rightVertices[0] = leftVertices[3]\n\n        this.drawPolygon(\n            topVertices,\n            new Border(blackStroke, null, null, null),\n            topColor\n        )\n        this.drawPolygon(\n            leftVertices,\n            new Border(null, null, blackStroke, blackStroke),\n            leftColor\n        )\n        this.drawPolygon(\n            rightVertices,\n            new Border(null, blackStroke, blackStroke, null),\n            rightColor\n        )\n\n        // Draw highlight lines\n        this.drawPolygon(\n            [\n                leftVertices[0], leftVertices[1], leftVertices[2], leftVertices[3]\n            ],\n            new Border(lightStroke, lightStroke, lightStroke, middleLeftStroke),\n            null\n        )\n\n        this.drawPolygon(\n            [\n                rightVertices[0], rightVertices[1], rightVertices[2], rightVertices[3],\n            ],\n            new Border(lightStroke, lightStroke, lightStroke, middleRightStroke),\n            null\n        )\n\n        // Final outline fix \"cell shading\"\n        this.drawPolygon(\n            [\n                topVertices[0], topVertices[1], topVertices[2],\n                rightVertices[0], rightVertices[3],\n                leftVertices[0],\n            ],\n            new Border(opts.stroke, opts.stroke, opts.stroke, opts.stroke),\n            null\n        )\n    }\n}\n\nexport {\n    Vector2,\n    Vector3,\n    Rect,\n    Area,\n    Edge,\n    Polyhedron,\n    Surface,\n    PolyhedronFactory,\n    PolyhedronFactoryOptions,\n    PolyhedronColorPalette,\n    PolyhedronOptions,\n    Painter,\n    ColorRgba,\n    Stroke\n}\n","import React from 'react'\nimport './App.scss';\nimport './Isometry';\nimport {ColorRgba, Painter, PolyhedronOptions, Stroke} from \"./Isometry\";\n\nconst defaults = new PolyhedronOptions(\n    128, 128, 128, 64, 64, 64, 64, 0,\n    new Stroke(1, ColorRgba.create(0, 0, 0, 255), true),\n    new ColorRgba('rgb(27,250,172)')\n)\n\nconst CANVAS_WIDTH = 640;\nconst CANVAS_HEIGHT = 640;\n\nclass Layer extends React.Component {\n    index;\n    options;\n    canvasRef;\n\n    constructor(props) {\n        super(props);\n        this.index = props.index\n        this.options = props.options\n        this.canvasRef = new React.createRef()\n        this.onDraw = props.onDraw\n    }\n\n    componentDidMount() {\n        if (!this.painter) {\n            this.painter = new Painter(this.canvasRef.current);\n        }\n        this.draw()\n        this.onDraw(this.options, this.index, this)\n    }\n\n    render() {\n        return <div key={this.index} className=\"layer\" style={{zIndex: this.index + 10}}>\n            <canvas className={\"editable-canvas\"} ref={this.canvasRef} width={CANVAS_WIDTH} height={CANVAS_HEIGHT}/>\n        </div>;\n    }\n\n    draw() {\n        //this.painter.clearCanvas()\n        this.painter.drawIsometricCube(this.options)\n        this.painter.update()\n    }\n}\n\nclass App extends React.Component {\n    updateCoolDownTimeout = null;\n    updateTimeoutDelay = 100;\n    viewportContainer;\n    layersContainer;\n    canvasGrid;\n    keyCount = 0;\n\n    constructor(props) {\n        super(props);\n        this.updateForm = this.updateForm.bind(this);\n        this.handleInputNumChange = this.handleInputNumChange.bind(this);\n        this.handleBaseColorChange = this.handleBaseColorChange.bind(this);\n        this.handleStrokeColorChange = this.handleStrokeColorChange.bind(this);\n        this.handleStrokeSizeChange = this.handleStrokeSizeChange.bind(this);\n        this.handleZoomChange = this.handleZoomChange.bind(this);\n        this.handleGridChange = this.handleGridChange.bind(this);\n        this.addLayer = this.addLayer.bind(this);\n        this.onLayerChange = this.onLayerChange.bind(this);\n        this.handleGridSnapChange = this.handleGridSnapChange.bind(this);\n        this.downloadLayers = this.downloadLayers.bind(this);\n        this.copyLayers = this.copyLayers.bind(this);\n        this.handlePosXChange = this.handlePosXChange.bind(this);\n        this.handlePosYChange = this.handlePosYChange.bind(this);\n\n        this.viewportContainer = React.createRef();\n        this.layersContainer = React.createRef();\n        this.canvasGrid = React.createRef();\n\n        this.state = {\n            zoom: 1.2,\n            layers: [defaults],\n            snapToGrid: true,\n            currentLayer: 0,\n        };\n    }\n\n    getCurrentOptions() {\n        return this.state.layers[this.state.currentLayer]\n    }\n\n    updateForm(options, index) {\n        //this.triggerPropsStateChange({currentLayer: index})\n    }\n\n    componentDidMount() {\n        let opts = this.getCurrentOptions()\n        this.drawGrid(opts.tileWidth, opts.tileHeight) // TODO: as component\n        this.handleZoomChange({target: {value: this.state.zoom}})\n        this.registerScrollOnDrag();// TODO: as component\n    }\n\n    render() {\n        let makeLayerComboItems = () => {\n            let opts = []\n            for (let i = 0; i < this.state.layers.length; i++) {\n                opts.push(<option key={i} value={i}>{i}</option>);\n            }\n            return opts\n        };\n\n        let makeLayers = () => {\n            let layers = []\n            for (let i = 0; i < this.state.layers.length; i++) {\n                layers.push(this.createLayer(i, this.state.layers[i]));\n            }\n            return layers\n        }\n\n        let opts = this.getCurrentOptions()\n\n        let snapMoveStepX = Math.floor(opts.tileWidth / 2)\n        let snapMoveStepXHalf = Math.floor(snapMoveStepX / 2)\n        let snapMoveStepY = Math.floor(opts.tileHeight / 2)\n\n        let moveStepX = this.state.snapToGrid ? snapMoveStepX : 8\n        let moveStepXHalf = Math.floor(moveStepX / 2)\n        let moveStepY = this.state.snapToGrid ? snapMoveStepY : 8\n\n        return <div className=\"ips-app\">\n            <header className=\"ips-menu ips-menu-top\">\n                <h1>Isometric Pixel Studio</h1>\n            </header>\n            <div className=\"ips-menu ips-menu-left\">\n                <div className=\"ips-form\">\n                    <div className=\"ips-form-group\">\n                        <header>Zoom: {Math.round(this.state.zoom * 10) * 10} %</header>\n                        <label>\n                            <input name=\"zoom\" type=\"range\" min={1} max={4} step={0.1}\n                                   value={this.state.zoom} onChange={this.handleZoomChange}/>\n                        </label>\n                    </div>\n                    <div className=\"ips-form-group\">\n                        <header>Grid: {opts.tileWidth}x{opts.tileHeight}px</header>\n                        <label>\n                            Tile width:\n                            <input name=\"tileWidth\" type=\"range\" min={0} max={320} step={8}\n                                   value={opts.tileWidth} onChange={this.handleGridChange}/>\n                        </label>\n                        <label>\n                            Tile height:\n                            <input name=\"tileHeight\" type=\"range\" min={0} max={240} step={8}\n                                   value={opts.tileHeight} onChange={this.handleGridChange}/>\n                        </label>\n                        <label>\n                            Snap to grid:\n                            <input style={{width: \"30px\"}} name=\"snapToGrid\"\n                                   type=\"checkbox\" checked={this.state.snapToGrid === true} value={1}\n                                   onChange={this.handleGridSnapChange}/>\n                        </label>\n                        <label>\n                            Rotation ({opts.rotation}%):\n                            <input name=\"rotation\" type=\"range\" min={-100} max={100} step={1}\n                                   value={opts.rotation} onChange={this.handleGridChange}/>\n                        </label>\n                    </div>\n                    <div className=\"ips-form-group\">\n                        <header>Layers</header>\n                        <label>\n                            Current layer:\n                            <select onChange={this.onLayerChange} name=\"layer\" value={this.state.currentLayer}>\n                                {makeLayerComboItems()}\n                            </select>\n                        </label>\n                        <label>\n                            <button name=\"addLayer\" onClick={this.addLayer}>Add Layer</button>\n                            <button name=\"removeLayer\">Remove Layer</button>\n                        </label>\n                    </div>\n                    <button className={\"primary-btn\"} name=\"copy\" onClick={this.copyLayers}>Copy to clipboard</button>\n                    <button className={\"primary-btn\"} name=\"download\" onClick={this.downloadLayers}>Download</button>\n                </div>\n            </div>\n            <div className=\"ips-viewport\" ref={this.viewportContainer}>\n                <div id={\"ips_layers\"} className=\"ips-layers\" ref={this.layersContainer}>\n                    {makeLayers()}\n                    <div className=\"layer layer-grid\" style={{zIndex: 1}}>\n                        <canvas width={CANVAS_WIDTH} height={CANVAS_HEIGHT} ref={this.canvasGrid}/>\n                    </div>\n                </div>\n            </div>\n            <div className=\"ips-menu ips-menu-right\">\n                <div className=\"ips-form\">\n                    <div className=\"ips-form-group\">\n                        <header>Position ({opts.posX},{opts.posY})</header>\n                        <label>\n                            X:\n                            <input name=\"posX\" type=\"range\" min={0} max={CANVAS_WIDTH - snapMoveStepX} step={moveStepX}\n                                   data-movestepy={moveStepY} value={opts.posX} onChange={this.handlePosXChange}/>\n                        </label>\n                        <label>\n                            Y:\n                            <input name=\"posY\" type=\"range\" min={0} max={CANVAS_HEIGHT - snapMoveStepY * 2}\n                                   step={moveStepY} data-movestepx={moveStepX}\n                                   value={opts.posY} onChange={this.handlePosYChange}/>\n                        </label>\n                    </div>\n                    <div className=\"ips-form-group\">\n                        <header>Size\n                            ({opts.sizeX} x {opts.sizeZ} x {opts.sizeY})\n                        </header>\n                        <label>\n                            X:\n                            <input name=\"sizeX\" type=\"range\" min={0} max={CANVAS_WIDTH - snapMoveStepXHalf}\n                                   step={moveStepXHalf}\n                                   value={opts.sizeX} onChange={this.handleInputNumChange}/>\n                        </label>\n                        <label>\n                            Z:\n                            <input name=\"sizeZ\" type=\"range\" min={0} max={CANVAS_WIDTH - snapMoveStepXHalf}\n                                   step={moveStepXHalf}\n                                   value={opts.sizeZ} onChange={this.handleInputNumChange}/>\n                        </label>\n                        <label>\n                            Y:\n                            <input name=\"sizeY\" type=\"range\" min={0} max={CANVAS_HEIGHT - snapMoveStepXHalf}\n                                   step={moveStepY}\n                                   value={opts.sizeY} onChange={this.handleInputNumChange}/>\n                        </label>\n                    </div>\n                    <div className=\"ips-form-group\">\n                        <header>Colors</header>\n                        <label>\n                            Base Color:\n                            <input name=\"baseColor\" type=\"color\"\n                                   value={opts.baseColor.toHexString()}\n                                   onChange={this.handleBaseColorChange}/>\n                        </label>\n                        <label>\n                            Stroke Color:\n                            <input name=\"strokeColor\" type=\"color\"\n                                   value={opts.stroke.color.toHexString()}\n                                   onChange={this.handleStrokeColorChange}/>\n                        </label>\n                        <label>\n                            Stroke Size:\n                            <input name=\"strokeSize\" type=\"range\" min={0} max={10}\n                                   value={opts.stroke.size} onChange={this.handleStrokeSizeChange}/>\n                        </label>\n                    </div>\n                </div>\n            </div>\n        </div>\n    }\n\n    onLayerChange(event) {\n        this.triggerStateChange('currentLayer', parseInt(event.target.value))\n    }\n\n    createLayer(layerIndex, layerOpts) {\n        let layer = <Layer key={layerIndex + \"-\" + this.keyCount}\n                           onDraw={this.updateForm} index={layerIndex} options={layerOpts}/>\n        this.keyCount++;\n        return layer\n    }\n\n    addLayer() {\n        let currOpts = this.state.layers[this.state.currentLayer]\n        let layerOpts = Object.assign(\n            {}, currOpts, {posY: currOpts.posY - currOpts.sizeY}\n        );\n        let layerIndex = this.state.layers.length\n        let layers = this.state.layers\n        layers.push(layerOpts)\n\n        this.triggerPropsStateChange({\n            layers: layers,\n            currentLayer: layerIndex\n        })\n    }\n\n    registerScrollOnDrag() {\n        const el = this.viewportContainer.current;\n        let isDown = false;\n        let startX;\n        let startY;\n        let scrollLeft;\n        let scrollTop;\n\n        el.addEventListener(\"mousedown\", e => {\n            isDown = true;\n            el.classList.add(\"active\");\n            startX = (e.pageX - el.offsetLeft)\n            startY = (e.pageY - el.offsetTop);\n            scrollLeft = el.scrollLeft;\n            scrollTop = el.scrollTop;\n        });\n\n        el.addEventListener(\"mouseleave\", () => {\n            isDown = false;\n            el.classList.remove(\"active\");\n        });\n\n        el.addEventListener(\"mouseup\", () => {\n            isDown = false;\n            el.classList.remove(\"active\");\n        });\n\n        el.addEventListener(\"mousemove\", e => {\n            if (!isDown) {\n                return;\n            }\n            e.preventDefault();\n            const x = e.pageX - el.offsetLeft;\n            const y = e.pageY - el.offsetTop;\n            const walkX = x - startX;\n            const walkY = y - startY;\n            el.scrollLeft = scrollLeft - walkX;\n            el.scrollTop = scrollTop - walkY;\n        });\n    }\n\n    triggerPropsStateChange(props, callback) {\n        if (!callback) {\n            callback = () => {\n            }\n        }\n        this.setState(prevState => {\n            let state = Object.assign({}, prevState, props);\n            callback(state)\n            return state\n        });\n    }\n\n    triggerStateChange(propName, propValue, callback) {\n        if (!callback) {\n            callback = () => {\n            }\n        }\n        this.setState(prevState => {\n            let state = Object.assign({}, prevState);\n            state[propName] = propValue\n            callback(state)\n            return state\n        });\n    }\n\n    triggerOptionsStateChange(propName, propValue, callback) {\n        if (!callback) {\n            callback = () => {\n            }\n        }\n        callback.bind(this);\n        this.setState(prevState => {\n            let state = Object.assign({}, prevState);\n            state.layers[state.currentLayer][propName] = propValue\n            callback(state)\n            return state\n        });\n    }\n\n    triggerOptionsStateChangeMultiple(opts, callback) {\n        if (!callback) {\n            callback = () => {\n            }\n        }\n        callback.bind(this);\n        this.setState(prevState => {\n            let state = Object.assign({}, prevState);\n            state.layers[state.currentLayer] = Object.assign({}, state.layers[state.currentLayer], opts);\n            callback(state)\n            return state\n        });\n    }\n\n    handlePosXChange(event) {\n        let opts = this.getCurrentOptions()\n        let val = parseInt(event.target.value)\n        let valY = opts.posY\n        if (val < this.getCurrentOptions().posX) {\n            valY -= parseInt(event.target.dataset.movestepy)\n        }else if (val > this.getCurrentOptions().posX) {\n            valY += parseInt(event.target.dataset.movestepy)\n        }\n        this.triggerOptionsStateChangeMultiple({\n            posX: val,\n            posY: valY\n        })\n    }\n\n    handlePosYChange(event) {\n        let opts = this.getCurrentOptions()\n        let val = parseInt(event.target.value)\n        let valX = opts.posX\n        if (val < this.getCurrentOptions().posY) {\n            valX += parseInt(event.target.dataset.movestepx)\n        }else if (val > this.getCurrentOptions().posY) {\n            valX -= parseInt(event.target.dataset.movestepx)\n        }\n        this.triggerOptionsStateChangeMultiple({\n            posX: valX,\n            posY: val\n        })\n    }\n\n    handleInputNumChange(event) {\n        this.triggerOptionsStateChange(event.target.name, parseInt(event.target.value))\n    }\n\n    handleBaseColorChange(event) {\n        this.triggerOptionsStateChange(event.target.name, new ColorRgba(event.target.value))\n    }\n\n    handleStrokeColorChange(event) {\n        let stroke = this.state.layers[this.state.currentLayer].stroke\n        stroke.color = new ColorRgba(event.target.value)\n        this.triggerOptionsStateChange('stroke', stroke)\n    }\n\n    handleStrokeSizeChange(event) {\n        let stroke = this.state.layers[this.state.currentLayer].stroke\n        stroke.size = parseInt(event.target.value)\n        this.triggerOptionsStateChange('stroke', stroke)\n    }\n\n    handleZoomChange(event) {\n        let zoom = parseFloat(event.target.value)\n        this.triggerStateChange('zoom', zoom, (state) => {\n            this.layersContainer.current.style.zoom = state.zoom;\n        })\n    }\n\n    handleGridChange(event) {\n        this.setState(prevState => {\n            let state = Object.assign({}, prevState);\n            state.layers[state.currentLayer][event.target.name] = parseInt(event.target.value)\n            let currOpts = state.layers[state.currentLayer]\n            this.drawGrid(currOpts.tileWidth, currOpts.tileHeight)\n            return state\n        });\n    }\n\n    handleGridSnapChange(event) {\n        this.triggerStateChange('snapToGrid', !!event.target.checked)\n    }\n\n    combineLayers() {\n        let combined = document.createElement('canvas')\n        combined.width = CANVAS_WIDTH\n        combined.height = CANVAS_HEIGHT\n        let ctx = combined.getContext('2d')\n        let layers = document.getElementsByClassName('editable-canvas')\n        Array.prototype.forEach.call(layers, function (canvas) {\n            ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height)\n        });\n        return combined\n    }\n\n    copyLayers(event) {\n        if (navigator.clipboard !== undefined && navigator.clipboard.write !== undefined) {\n            let combined = this.combineLayers()\n            // eslint-disable-next-line no-undef\n            combined.toBlob(blob => navigator.clipboard.write([new ClipboardItem({'image/png': blob})]));\n        } else {\n            this.downloadLayers(event)\n        }\n    }\n\n    downloadLayers(event) {\n        let combined = this.combineLayers()\n\n        let dataURL = combined.toDataURL(\"image/png\");\n        let link = document.createElement('a');\n        link.download = \"isometric-studio-export.png\";\n        link.target = '_blank';\n        link.href = dataURL // dataURL.replace(\"image/png\", \"image/octet-stream\");\n        link.click();\n    }\n\n    drawGrid(tileWidth, tileHeight) {\n        const canvas = this.canvasGrid.current\n        const c = canvas.getContext('2d')\n        const width = canvas.width\n        const height = canvas.height\n        const gridNumX = 100\n        const gridNumY = 100\n        const lineColor = '#a6a6a6'\n\n        c.translate(width / 2, -height)\n\n        const block = function (x, y, z) {\n            this.x = x\n            this.y = y\n            this.z = z\n\n            this.draw = function () {\n                c.save()\n                c.translate((this.x - this.y) * tileWidth / 2, (this.x + this.y) * tileHeight / 2)\n\n                // Draw top of the tile\n                c.beginPath()\n                c.moveTo(0, -this.z * tileHeight)\n                c.lineTo(tileWidth / 2, tileHeight / 2 - this.z * tileHeight)\n                c.lineTo(0, tileHeight - z * tileHeight)\n                c.lineTo(-tileWidth / 2, tileHeight / 2 - this.z * tileHeight)\n                c.closePath()\n                c.fillStyle = '#fff'\n                c.fill()\n\n                // right side of the tile\n                c.beginPath()\n                c.moveTo(tileWidth / 2, tileHeight / 2 - this.z * tileHeight)\n                c.lineTo(0, tileHeight - this.z * tileHeight)\n                c.lineTo(0, tileHeight)\n                c.lineTo(tileWidth / 2, tileHeight / 2)\n                c.closePath()\n                c.fillStyle = lineColor\n                c.fill()\n\n                // left side od the tile\n                c.beginPath()\n                c.moveTo(-tileWidth / 2, tileHeight / 2 - this.z * tileHeight)\n                c.lineTo(0, tileHeight - this.z * tileHeight)\n                c.lineTo(0, tileHeight)\n                c.lineTo(-tileWidth / 2, tileHeight / 2)\n                c.closePath()\n                c.fillStyle = lineColor\n                c.fill()\n\n                c.restore()\n            }\n        }\n\n        const draw = function () {\n            c.clearRect(0, 0, width, height)\n\n            for (let x = 0; x < gridNumX; x++) {\n                for (let y = 0; y < gridNumY; y++) {\n                    let item = new block(x, y, 1)\n                    item.draw()\n                }\n            }\n        }\n\n        draw()\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}